## üìù Cinco Exerc√≠cios para Fixar a Recurs√£o e Busca Bin√°ria

### 1. Fatorial Recursivo (O B√°sico do Caso Base)

Antes de voltar √† busca bin√°ria, precisamos garantir que o conceito de **parar** e **reduzir** (que gerou o erro de `StackOverflow`) esteja 100% fixo. O c√°lculo do Fatorial √© o exemplo cl√°ssico.

**O Problema:** Escreva uma fun√ß√£o recursiva `fatorial(n: Int)` que calcule o fatorial de um n√∫mero inteiro positivo $n$.
$$n! = n \times (n-1) \times (n-2) \times \dots \times 1$$

* **Caso Base de Sucesso (Parada):** Qual √© o fatorial de 1? (Ou 0?)
* **Caso Recursivo (Redu√ß√£o):** Como voc√™ expressa $n!$ em termos de $(n-1)!$?

### 2. Contagem Simples (Medindo o Universo)

Este exerc√≠cio testa sua capacidade de **reduzir a lista** (D&C) sem a complica√ß√£o da busca bin√°ria.

**O Problema:** Escreva uma fun√ß√£o recursiva `contarElementos(lista: Array<Int>)` que retorna o n√∫mero de elementos na lista, **sem usar** loops (`for`/`while`) nem a propriedade `.size`.

* **Caso Base:** Qual √© o tamanho de uma lista vazia?
* **Caso Recursivo:** Se voc√™ "arrancar" um elemento da lista e passar o resto para a fun√ß√£o recursiva, como voc√™ usa o resultado dela para obter a contagem total?

### 3. Busca Bin√°ria Modificada (Primeira Ocorr√™ncia)

Agora voltamos √† Busca Bin√°ria, mas com um requisito de entrevista que exige um racioc√≠nio l√≥gico extra.

**O Problema:** Voc√™ est√° em uma lista ordenada com duplicatas (ex: `[2, 4, 4, 4, 6, 8]`). Escreva uma fun√ß√£o recursiva que n√£o apenas encontre o alvo, mas encontre o **√≠ndice da primeira ocorr√™ncia** do alvo.

* Se o `meio` for igual ao `alvo`, voc√™ n√£o pode parar. Voc√™ precisa checar se o elemento **anterior** tamb√©m √© o alvo.
* **A D√∫vida:** Se o `meio` √© o alvo, voc√™ continua buscando na **esquerda** (para achar a primeira ocorr√™ncia), ou para? (Dica: O Caso Base de sucesso √© mais complexo agora.)

### 4. Busca em Array Rotacionado (O Twist da Big Tech)

Este √© um problema cl√°ssico de Big Tech que usa a l√≥gica da Busca Bin√°ria, mas a lista n√£o est√° totalmente ordenada.

**O Problema:** Voc√™ tem um array ordenado que foi rotacionado em um ponto desconhecido (ex: `[6, 7, 8, 1, 2, 3, 4]`). Escreva uma fun√ß√£o recursiva para encontrar um alvo nessa lista.

* **O Desafio:** Voc√™ ainda calcula o `meio`, mas agora voc√™ precisa decidir se a metade **esquerda** ou a metade **direita** est√° ordenada, para saber qual metade descartar.
* **Pista:** Compare `lista[inicio]` com `lista[meio]` e `lista[fim]` para descobrir qual metade do array est√° bem comportada.

### 5. Soma de Subvetores (Conectando com o Merge Sort)

Este exerc√≠cio conecta a l√≥gica de divis√£o da Busca Bin√°ria com outros algoritmos de D&C (como o Merge Sort, que voc√™ estudar√° no pr√≥ximo cap√≠tulo).

**O Problema:** Escreva uma fun√ß√£o recursiva `somaSubVetor(lista: Array<Int>, inicio: Int, fim: Int)` que, usando apenas a recurs√£o, calcule a soma de todos os elementos dentro dos limites `inicio` e `fim`.

* **Caso Base:** Quando a janela (`inicio` e `fim`) tem apenas 1 elemento, qual √© a soma? E se tiver 0 elementos?
* **Caso Recursivo:** Divida a lista no `meio`. Chame a fun√ß√£o recursivamente para a metade esquerda, chame para a metade direita e **some os dois resultados**.

---
